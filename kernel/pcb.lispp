import stdio "stdio"
import utils "utils"

# Initializes enums for process states
const int_PROCREADY 0
const int_PROCRUNNING 1
const int_PROCBLOCKED 2

# Initializes address constant for PCB STATE
const int_PCBSTATE 0

# Initializes address constant for the program counter
const int_PCBPROGRAMCOUNTER 1

# Initializes address constant for the User Registers
const int_PCBUSRREGS 2

# Starting address for the stack constants
const int_PCBSTACKSIZE 18
const int_PCBSTACKSTART 19

function setProcessState(int_processIndex int_processState) {
    set *int_pcbBlockAddress ([] **int_proc int_processIndex)
    (<> *int_pcbBlockAddress int_processState int_PCBSTATE)
}

function getProcessState(int_processIndex) {
    set int_processState ([] ([] **int_proc int_processIndex) int_PCBSTATE)
} returns int_processState

function allocateNextBlock(int_processIndex int_order) {
    set int_searchingForMemory 1
    set int_memoryIndex -1

    set int_i 0 for int_i (&& int_searchingForMemory (< int_i int_memBlocksSize)) (++ int_i) {
        if (= ([] *int_memBlocks int_i) 0) {
            (<> *int_memBlocks (| (<< int_processIndex 8) int_order) int_i)
            set int_memoryIndex int_i
            set int_searchingForMemory 0
        }
    }
} returns int_memoryIndex

function getNumberOfOpenMemBlocks() {
    set int_numOpenBlocks 0
    
    for int_i (< int_i int_memBlocksSize) (++ int_i) {
        if (= ([] *int_memBlocks int_i) 0) {
            set int_numOpenBlocks (++ int_numOpenBlocks)
        }
    }
} returns int_numOpenBlocks

function saveUserRegisters(int_processIndex) {
    set *int_pcbBlockAddress ([] **int_proc int_processIndex)
    set int_temp 0 (<> *int_pcbBlockAddress KERNEL.int_UserReg0 int_PCBUSRREGS)
    set int_temp (++ int_temp) (<> *int_pcbBlockAddress KERNEL.int_UserReg1 (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) (<> *int_pcbBlockAddress KERNEL.int_UserReg2 (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) (<> *int_pcbBlockAddress KERNEL.int_UserReg3 (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) (<> *int_pcbBlockAddress KERNEL.int_UserReg4 (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) (<> *int_pcbBlockAddress KERNEL.int_UserReg5 (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) (<> *int_pcbBlockAddress KERNEL.int_UserReg6 (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) (<> *int_pcbBlockAddress KERNEL.int_UserReg7 (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) (<> *int_pcbBlockAddress KERNEL.int_UserReg8 (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) (<> *int_pcbBlockAddress KERNEL.int_UserReg9 (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) (<> *int_pcbBlockAddress KERNEL.int_UserRegA (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) (<> *int_pcbBlockAddress KERNEL.int_UserRegB (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) (<> *int_pcbBlockAddress KERNEL.int_UserRegC (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) (<> *int_pcbBlockAddress KERNEL.int_UserRegD (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) (<> *int_pcbBlockAddress KERNEL.int_UserRegE (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) (<> *int_pcbBlockAddress KERNEL.int_UserRegF (+ int_PCBUSRREGS int_temp))
}

function loadUserRegisters(int_processIndex) {
    set *int_pcbBlockAddress ([] **int_proc int_processIndex)
    set int_temp 0 set KERNEL.int_UserReg0 ([] *int_pcbBlockAddress int_PCBUSRREGS)
    set int_temp (++ int_temp) set KERNEL.int_UserReg1 ([] *int_pcbBlockAddress (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) set KERNEL.int_UserReg2 ([] *int_pcbBlockAddress (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) set KERNEL.int_UserReg3 ([] *int_pcbBlockAddress (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) set KERNEL.int_UserReg4 ([] *int_pcbBlockAddress (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) set KERNEL.int_UserReg5 ([] *int_pcbBlockAddress (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) set KERNEL.int_UserReg6 ([] *int_pcbBlockAddress (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) set KERNEL.int_UserReg7 ([] *int_pcbBlockAddress (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) set KERNEL.int_UserReg8 ([] *int_pcbBlockAddress (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) set KERNEL.int_UserReg9 ([] *int_pcbBlockAddress (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) set KERNEL.int_UserRegA ([] *int_pcbBlockAddress (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) set KERNEL.int_UserRegB ([] *int_pcbBlockAddress (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) set KERNEL.int_UserRegC ([] *int_pcbBlockAddress (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) set KERNEL.int_UserRegD ([] *int_pcbBlockAddress (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) set KERNEL.int_UserRegE ([] *int_pcbBlockAddress (+ int_PCBUSRREGS int_temp))
    set int_temp (++ int_temp) set KERNEL.int_UserRegF ([] *int_pcbBlockAddress (+ int_PCBUSRREGS int_temp))
}

function setProgramCounter(int_processIndex int_programCounter) {
    set *int_pcbBlockAddress ([] **int_proc int_processIndex)
    (<> *int_pcbBlockAddress int_programCounter int_PCBPROGRAMCOUNTER)
}

# Clear out the old stack:
function emptyStack() {
    # Since this function is on top of the stack, we need to
    # save that return address
    set int_rval (KERNEL.POP)
    # Clear the stack
    while (i KERNEL.int_StackSize) {
        set int_temp (KERNEL.POP)
    }
    # Put the return address we saved back onto the stack,
    # allowing this function to return.
    (KERNEL.PUSH int_rval)
}

function saveStack(int_processIndex) {
    # Since this function is on top of the stack, we need to
    # save that return address
    set int_rval (KERNEL.POP)

    set *int_pcbBlockAddress ([] **int_proc int_processIndex)

    (<> *int_pcbBlockAddress KERNEL.int_StackSize int_PCBSTACKSIZE)
    
    set int_i 0
    while (i KERNEL.int_StackSize) {
        (<> *int_pcbBlockAddress (KERNEL.POP) (+ int_PCBSTACKSTART int_i))
        set int_i (++ int_i)
    }

    # Put the return address we saved back onto the stack,
    # allowing this function to return.
    (KERNEL.PUSH int_rval)
}

function defaultStack(int_processIndex) {
    set *int_pcbBlockAddress ([] **int_proc int_processIndex)
    (<> *int_pcbBlockAddress 1 int_PCBSTACKSIZE)
    (<> *int_pcbBlockAddress 0 int_PCBSTACKSTART)
}

# Loads the stack for a program and resumes its execution
function loadStackAndRun(int_processIndex) {
    set *int_pcbBlockAddress ([] **int_proc int_processIndex)
    
    # We have to be careful with the return stack at this point,
    # because we essentially just cleared it out. For example, returning
    # now would cause a stack underflow.
    (emptyStack)

    set int_stackSize ([] *int_pcbBlockAddress int_PCBSTACKSIZE)
    set int_i int_stackSize for int_i (> int_i 0) (-- int_i) {
        (KERNEL.PUSH ([] *int_pcbBlockAddress (+ int_PCBSTACKSIZE int_i)))
    }

    # This pushes the program counter onto the stack that was just emptied and set up
    # This is okay, because once the function completes the program counter will be popped
    (setProcessState int_processIndex int_PROCRUNNING)

    (KERNEL.RETI)
}

function unlockMemory(int_processIndex) {
    (KERNEL.LOCK KERNEL.int_PageStackSize)

    set int_processIndex (++ int_processIndex)

    for int_i (< int_i int_memBlocksSize) (++ int_i) {
        if (&& (= (>> ([] *int_memBlocks int_i) 8) int_processIndex) (& ([] *int_memBlocks int_i) 0xFF)) {
            (KERNEL.UNLOCK int_i)
        }
    }
}

function freeMemory(int_processIndex) {
    set int_processIndex (++ int_processIndex)

    for int_i (< int_i int_memBlocksSize) (++ int_i) {
        if (= (>> ([] *int_memBlocks int_i) 8) int_processIndex) {
            (<> *int_memBlocks 0 int_i)
        }
    }
}

function extFetch(int_diskIndex int_address) {
    set int_addr (<< int_address 1)
    (KERNEL.EXTFETCH int_diskIndex 0 int_addr)
    set int_2byte KERNEL.int_ExtBufferIn
    (KERNEL.EXTFETCH int_diskIndex 0 (++ int_addr))
    set int_2byte (| (<< int_2byte 8) KERNEL.int_ExtBufferIn)
} returns int_2byte

function extWrite(int_diskIndex int_address) {
    (KERNEL.EXTWRITE int_diskIndex 0 int_address)
}

function findOpenProcessSlot() {
    set int_searchingForBlock 1
    set int_processIndex -1

    # Finds an open process slot to place process into
    for int_i (&& int_searchingForBlock (< int_i int_procSize)) (++ int_i) {
        if (= (addr ([] **int_proc int_i)) -1) {
            set int_processIndex int_i
            set int_searchingForBlock 0
        }
    }
} returns int_processIndex

function getCurrentlyRunningProcess() {
    set int_runningProcessIndex -1
    set int_searchingForRunningProcess 1

    for int_i (&& int_searchingForRunningProcess (< int_i int_procSize)) (++ int_i) {
        if(= (addr ([] **int_proc int_i)) -1) {

        }
        else {
            if (= (getProcessState int_i) int_PROCRUNNING) {
                set int_runningProcessIndex int_i
                set int_searchingForRunningProcess 0
            }
        }
    }
} returns int_runningProcessIndex

function switchProcess(int_current int_processIndex) {
    if (= int_current int_processIndex) {
        (loadStackAndRun int_processIndex)
    }
    else {
        # Swap the processes
        if(= int_current -1) {

        }
        else {
            if (= (addr ([] **int_proc int_current)) -1) {

            }
            else {
                (setProcessState int_current int_PROCREADY)
                (saveUserRegisters int_current)
            }
        }

        (loadUserRegisters int_processIndex)
        (unlockMemory int_processIndex)
        (loadStackAndRun int_processIndex)
    }
}

function getNextProcess(int_current) {
    set int_i (% (++ int_current) int_procSize)
    set int_next -1
    while (&& (= int_next -1) (= (= int_current int_i) 0)) {
        if(= (addr ([] **int_proc int_i)) -1) {

        }
        else {
            if (= (getProcessState int_i) int_PROCREADY) {
                set int_next int_i
            }
        }
        set int_i (% (++ int_i) int_procSize)
    }
} returns int_next

function killProcess(int_processIndex) {
    (freeMemory int_processIndex)
    (<> **int_proc (ptr -1) int_processIndex)
}

function createProcess(int_diskIndex) {
    set int_status 0

    (stdio.print "KERNEL Memory BINEND: ")
    (stdio.printHex (addr KERNEL.*int_BINEND))

    # Result placed in KERNEL.int_ExtBufferIn
    

    set int_progSize (extFetch int_diskIndex 0)
    (stdio.print " Prog Size Byte: ")
    (stdio.printHex int_progSize)
    set int_numBlocks (++ (>> int_progSize 8))

    # Returns the index of a process slot it finds
    set int_processIndex (findOpenProcessSlot)

    if (= int_processIndex -1) {
        (stdio.print "ERROR in createProcess(): Could not find process slot.")
        set int_status 1
    }
    else {
        # Figure out the number of empty pages.
        if (> (getNumberOfOpenMemBlocks) int_numBlocks) {

            set int_pcbIndex (allocateNextBlock (++ int_processIndex) 0)
            
            set int_progByte 1

            (stdio.newline)
            (stdio.print "Allocating...")
            (stdio.newline)
            set int_i 1 for int_i (<= int_i int_numBlocks) (++ int_i) {
                
                set int_memBlock (allocateNextBlock (++ int_processIndex) int_i)
                
                (stdio.printU int_progSize)
                (stdio.printU (<< (-- int_i) 8))

                for int_j (< int_j (utils.min (- int_progSize (<< (-- int_i) 8)) 256)) (++ int_j) {
                    set int_memoryByte (extFetch int_diskIndex int_progByte)

                    (stdio.printHex int_memoryByte) (stdio.print " ")

                    (<> (ptr (<< int_memBlock 8)) int_memoryByte int_j)
                    set int_progByte (++ int_progByte)
                }

                (stdio.newline)
            }

            (<> **int_proc (ptr (<< int_pcbIndex 8)) int_processIndex)
            (setProcessState int_processIndex int_PROCREADY)
            (saveUserRegisters int_processIndex)
            (setProgramCounter int_processIndex 0)

            # Create default stack
            (defaultStack int_processIndex)

            (stdio.print " Process Index: ")
            (stdio.printU int_processIndex)
            
            (stdio.print " Memory Index: ")
            (stdio.printU int_pcbIndex)

            (stdio.print " Process State: ")
            (stdio.printU (getProcessState int_processIndex))

        }
        else {
            (stdio.print "ERROR in createProcess(): Not enough memory to load program")

            set int_status 2
        }
    }
} returns int_status
